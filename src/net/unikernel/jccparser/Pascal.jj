/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Pascal.jj */
/*@egen*/PARSER_BEGIN(PascalParser)

package net.unikernel.jccparser;

public class PascalParser/*@bgen(jjtree)*/implements PascalParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTPascalParserState jjtree = new JJTPascalParserState();

/*@egen*/
	public java.util.List<ParseException> syntaxErrors =
		new java.util.ArrayList<ParseException> ();

	void recover (ParseException ex, int recoveryPoint)
	{
		syntaxErrors.add (ex);
		Token t;
		do
		{
			t = getNextToken();
		}
		while (t.kind != EOF && t.kind != recoveryPoint);
	}
}

PARSER_END(PascalParser)

/* WHITE SPACE */
SKIP:
{
	< WHITESPACE: " " | "\t" | "\n" | "\r" | "\f">
}

/* COMMENTS */
TOKEN:
{
	<MULTI_LINE_COMMENT:"{"(~["*"])*"}">
	| <MULTI:"(""*"(~["*"])*"*"")">
}

/* SEPARATORS */
TOKEN :
{
	< LPAREN: "(" >
	| < RPAREN: ")" >
	| < COLON: ":" >
	| < SEMICOLON: ";" >
	| < DOT: "." >
	| < COMMA:",">
}

/* OPERATORS */
TOKEN:
{
	<PLUS:"+">
	| <MINUS:"-">
	| <MULTIPLY:"*">
	| <DIVIDE:"/">
        | <DIV:"div">
	| <ASSIGN: <COLON>"=">
}

/* KEYWORDS */
TOKEN:
{
	<PROGRAM:"program">
	| <VAR:"var">
	| <INTEGER:"integer">
	| <REAL:"real">
	| <BEGIN:"begin">
	| <END:"end">
	| <FOR:"for">
	| <TO:"to">
        | <DO:"do">
	| <DOWNTO:"downto">
	| <WRITE:"write">
	| <WRITELN:"writeln">
	| <READ:"read">
	| <READLN:"readln">
}

/* IDENTIFICATOR AND LITERALS */
TOKEN:
{
	<ID: <LETTER>(<LETTER>|<DIGIT>)*>
	| <LETTER:(["A"-"Z","a"-"z"])+>
        | <NUMBER: (<DIGIT>)+ ("."(<DIGIT>)+ )* >
	| <DIGIT:["0"-"9"]>
	| <DIGITS:(<DIGIT>)+>
	| <SIGN:["+", "-"]>
}



/* PARSER STARTS HERE */

/*every proram ends with EOF*/
SimpleNode parse() :
{/*@bgen(jjtree) parse */
  SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) parse */
        try {
/*@egen*/
	try
	{
		prog()
		<EOF>
		{return jjtn000;}
	}
	catch(ParseException ex)
	{
		recover (ex, SEMICOLON);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*all program structure*/
void prog() : {/*@bgen(jjtree) prog */
  SimpleNode jjtn000 = new SimpleNode(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) prog */
    try {
/*@egen*/
    <PROGRAM> <ID> <SEMICOLON> (<VAR> var_list())* <BEGIN> (stmt_list())* <END> <DOT>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*var body */
void var_list() : {/*@bgen(jjtree) var_list */
  SimpleNode jjtn000 = new SimpleNode(JJTVAR_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) var_list */
    try {
/*@egen*/
    (id_list() <COLON> type() <SEMICOLON>)+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*types*/
void type() : {/*@bgen(jjtree) type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) type */
    try {
/*@egen*/
    <INTEGER> | <REAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* ids seperated by comma (for initialization for example) */
void id_list() : {/*@bgen(jjtree) id_list */
  SimpleNode jjtn000 = new SimpleNode(JJTID_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) id_list */
    try {
/*@egen*/
    <ID> (<COMMA> id_list())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*list of statements */
void stmt_list() : {/*@bgen(jjtree) stmt_list */
  SimpleNode jjtn000 = new SimpleNode(JJTSTMT_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) stmt_list */
    try {
/*@egen*/
    (stmt() <SEMICOLON>)+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*statement (shit that ends with semicolon)*/
void stmt() : {/*@bgen(jjtree) stmt */
  SimpleNode jjtn000 = new SimpleNode(JJTSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) stmt */
    try {
/*@egen*/
    (<ID> <ASSIGN> exp())
    |((<WRITE>|<WRITELN>) <LPAREN> exp() <RPAREN> )
    |((<READ>|<READLN>) <LPAREN> id_list() <RPAREN> )
    |(<FOR> for_index_exp() <DO> body())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* variable or numeric value */
void numeric_val() : {/*@bgen(jjtree) numeric_val */
  SimpleNode jjtn000 = new SimpleNode(JJTNUMERIC_VAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) numeric_val */
    try {
/*@egen*/
    <NUMBER>|<ID>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* simple expression with binary operator */
void exp() : {/*@bgen(jjtree) exp */
  SimpleNode jjtn000 = new SimpleNode(JJTEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) exp */
    try {
/*@egen*/
    numeric_val() ((<PLUS>|<MINUS>|<MULTIPLY>|<DIVIDE>|<DIV>) numeric_val())?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*expression for "for" loop */
void for_index_exp() : {/*@bgen(jjtree) for_index_exp */
  SimpleNode jjtn000 = new SimpleNode(JJTFOR_INDEX_EXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) for_index_exp */
    try {
/*@egen*/
    <ID> <ASSIGN> exp() <TO> exp()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*Body for some loops and other stuff (begin ... end) */
void body() : {/*@bgen(jjtree) body */
  SimpleNode jjtn000 = new SimpleNode(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) body */
    try {
/*@egen*/
    <BEGIN> stmt_list() <END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
